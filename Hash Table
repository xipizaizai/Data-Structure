1. Two sum:
        find two elements that sum is target
        use hashmap to search for target-nums[i], if not exist, store nums[i],else found it
        Time complexity: O(N)
2. word pattern:
        use the "map.put": which will return the previous value associated with key, 
        or null if there was no mapping for key
3. How many index till you get a higher element:
        Use a stack can easily fulfill, when occur a higher number, you can pop all the index which is
        smaller than the current number.
4. Top K frequent element:
        matter of frequency, you can use hashmap to get the frequency
        Top n == sort by frequency-> use comparator -> Collections.sort(list,comparator)
5. Goup string together:
        Sort them to see if they meet specific pattern
        Time Complexity of Sorting is O(NlogN)
6.Longest substring without repeated character:
        use hash set to record the longest substring from i to j
        if repeated occur, remove charAt(i) i++ j not change continue searching
        Time complexity is O(n)
        Space Complexity is O(set.size())
7. 4Sum(return # of pairs):
        using HashMap to store sum of 2 lists, and for the other 2 lists, check if map.contains(target-sum)
        Time Complexity:O(n^2)
8. Subarray Sum Equal K:
        Subarray can use prifix sum array, find (sum-target)
        trick is you need to add 0 into map which has count=1
9. Maximum Size Subarray Sum Equals k:
        which is follow up of the question above, remember to use presum, and if sum is not contained, store the sum into map,but if sum is already exist in the map, do not update the sum because it maybe larger than now.
        
10. First Unique Character in a String:O(n)
        use int array with 256 size which can contains more characters, and two passes of array. Find the character with frequency 1
        
11. Remove Duplicate Letters: O(n)
        Idea is to find the smaller lexiorder character but need to meet the need of still have previous letters in rest of the array. So when we want to maintain a structure which can peek previous chacters, we need stack! 
        use visited boolean array to skip already visited char and use int[]count = new int[256] to record the frequency of the char: to see that there still have chars in the rest of the array so that we can pop it out.
        then use stringbuilder to append all the chars in the stack.
12.Min stack: each operation is O(1)
        idea is to get min of the whole stack, so that using only one stack and record the min value using a integer, each time you found a smaller one than min, update min and push min into stack then push element into stack. when pop the thing out,if the element on top is min, then after pop it, you should update min value with the value beneath it and then pop it.
        
13. Longest Consecutive Sequence:O(n)
       First turn the input into a set of numbers. That takes O(n) and then we can ask in O(1) whether we have a certain number.Then go through the numbers. If the number x is the start of a streak (i.e., x-1 is not in the set), then test y = x+1, x+2, x+3, ... and stop at the first number y not in the set. The length of the streak is then simply y-x and we update our global best with that. Since we check each streak only once, this is overall O(n).
        
14. Evaluate Reverse Polish Notation O(n):
        Idea is to use a stack to record item until find a opertor, then pop out the first two element to do the operation, then push them into the stack.

15. Basic Calculator:O(n)
        idea is the same with 14, then use a stack to record the number in the parenthesis, others just use operator to calculate the result.
        do not forget the last number which is need be added to the result so far.
        
16.Flatten Nested List Iterator:O(n)
        Idea is we push all the nestedList into the stack from back to front, so when we pop the stack, it returns the very first element. Second, in the hasNext() function, we peek the first element in stack currently, and if it is an Integer, we will return true and pop the element. If it is a list, we will further flatten it. 
        
        
