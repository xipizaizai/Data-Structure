1. Reverse Vowels of a String O(n)+O(1):
    idea is using two pointers, when met the vowel char, swap them and keep finding. use stack can make the search in O(1)time, and the space complexity is O(1) because of using two pointers.
    
2. Candy: O(n)
    idea is to find the minimum sum of candy, the better idea is to create two arrays fill with one. And linear scan input array and if neighbor is greater, then add one more
    you go from left to right and right to left- in total 2 pass and then for two arrays, each element will get the max one as the final output.
    
3. Minimum Size Subarray Sum:O(n)
    Idea is to use 2 pointers, sum the numbers from i to j until it is larger than sum, then i++ and sum-=nums[i], keep finding, after finding all the elements in the array, get the minimum one.

4. Substring with Concatenation of All Words:O(mn)
    Idea is to use sliding window, which has the length of words.length and use hashMap to see if the substrin contains all the element in the wordlist. if yes then add the index into the result.
    Remind of copy of hashmap because every time need to check whether new substring contains.


    
